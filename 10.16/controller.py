"""Контроллер MVC."""

from enum import Enum
# from functools import reduce
# from operator import add, or_


# КОММЕНТАРИЙ: а ещё можно использовать в качестве дополнительного типа tuple и перечислить несколько допустимых вариантов ответа, например ('1', 'yes', 'y', 'да', 'д')
# КОММЕНТАРИЙ: или использовать set и {'1', 'y', 'д'}, а в обработке ввода брать первый символ от непустого ввода
class UserAnswer(str, Enum):
    YES = '1'
    NO = '0'

    @classmethod
    def values(cls):
        return ''.join(cls)
        # КОММЕНТАРИЙ: для tuple:
        # return reduce(add, cls)
        # КОММЕНТАРИЙ: для set:
        # return reduce(or_, cls)


class Application:
    """
    Контроллер
    """
    def __init__(self,
                 # КОММЕНТАРИЙ: для аннотаций собственных типов в модулях, которые во избежание закольцовывания не должны импортировать друг друга, используются дженерики — абстрактные классы, объявленные в отдельных модулях, иногда только заголовком, чаще с аннотациями требуемых атрибутов — от них наследуются уже конкретные реализации
                 view: 'CLIView',
                 # ИСПРАВИТЬ: в точке входа вы передаёте сюда объект класса, а не экземпляр — если это именно то поведение, которого вы ожидаете, то аннотацию следует дополнить использованием Type из модуля typing
                 model: 'Email'):
        self.view = view
        self.model = model
        self.email = None

    def start(self) -> None:
        """Старт приложения"""
        self.view.start()
        self.check_email()

    def check_email(self) -> None:
        """Проверяет email на корректность"""
        try:
            # ИСПРАВИТЬ: с точки зрения контроллера, получение данных и проверка — это разные действия — стоит разнести их в разные методы
            self.email = self.model(self.view.input_email())
            # ДОБАВИТЬ: реализацию требования задания выйти из цикла ввода адреса по вводу пустой строки
            self.view.valid_email()
            self.save_email()
        except ValueError:
            self.view.invalid_email()
            self.check_email()

    def save_email(self) -> None:
        """Записывает в файл"""
        # УДАЛИТЬ: непосредственное получение ввода — например, с помощью input() — прерогатива представления, а не контроллера
        save_or_not = input("Сохранить?\n").lower()
        # ИСПРАВИТЬ: применение множественного наследования позволяет экземпляру перечислителя использовать большинство определённых атрибутов дополнительного типа, например, __eq__() — это, в частности, означает, что сравнение можно проводить не с атрибутом value экземпляра перечислителя, а с самим экземпляром перечислителя
        if save_or_not == UserAnswer.YES.value:
            self.email.save()
        # КОММЕНТАРИЙ: если вы ожидаете только цифру, то метод lower() бесполезен
        save_or_not = input("Продолжить?\n").lower()
        if save_or_not == UserAnswer.YES.value:
            self.check_email()
        # КОММЕНТАРИЙ: здесь вы реализуете сценарий, в котором любой отличный от положительного ответ трактуется как отрицательный, и такой сценарий вполне жизнеспособен — однако, периодически вам будет необходимо получить именно определённый ввод (или любое другое поступление данных) — в таких ситуациях пригождается условно-бесконечный цикл с проверкой того является ли ввод принципиально допустимым (ещё до обработки каждого варианта ввода), а в перечислитель с вариантами ответов для этого добавляется классовый (важно) метод values()
        else:
            self.end()

    def end(self) -> None:
        """Завершает работу"""
        self.view.end_view()

