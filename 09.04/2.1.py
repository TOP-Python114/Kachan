# Разработайте класс FilmCard, который описывает карточку с информацией о фильме в каталоге онлайн-кинотеатра.
# Используйте композицию для создания возможной связи с другими фильмами.
# Около десяти полей у вас должно быть.
# Реализуйте шаблон Фабрики для создания экземпляров FilmCard.

from enum import Enum


# ИСПОЛЬЗОВАТЬ: преимущество перечислителя перед списком заключается в том, что далее мы можем использовать имена атрибутов, вне зависимости от того, какие значения в этих атрибутах — вы же здесь объявляете и далее используете этот перечислитель скорее как список
class Genre(Enum):
    # ИСПОЛЬЗОВАТЬ: принято атрибуты перечислителя писать в верхнем регистре (потому что они почти всегда являются константами)
    ROMANCE = 1
    CRIME = 2
    DRAMA = 3
    HISTORY = 4
    MYSTERY = 5
    ADVENTURE = 5
    HORROR = 6
    COMEDY = 7
    FAMILY = 8
    WAR = 9
    FANTASY = 10


class Actor:

    def __init__(self, role: str, fio: str):
        # КОММЕНТАРИЙ: если вы создаёте один экземпляр этого класса для каждой роли, то тогда это не Актёр, а Роль — и тогда этот словарь вам не нужен
        self.films = {}
        self.fio = fio
        # КОММЕНТАРИЙ: а если вы хотите, чтобы один экземпляр хранил информацию об одном актёре, то словарь можно оставить, а атрибут role явно лишний
        self.role = role

    # КОММЕНТАРИЙ: этот метод как раз пригодился бы в ситуации, когда у одного актёра много ролей — только очевидно, что метод должен принимать какие-то аргументы
    def to_create(self) -> dict:
        """
        Создает словарь с ролью и именем актера

        :param name: наименование фильма
        :param role: роль актера
        """
        self.films.update({self.role: self.name})
        return self.films

    # УДАЛИТЬ: это свойство бесцельно дублирует существующее публичное поле
    @property
    def name(self):
        return self.fio


class FilmCard:

    def __init__(self,
                 id_: int,
                 name: str,
                 # ИСПРАВИТЬ: разве в параметр жанр вы передаёте str объект в качестве аргумента? (нет)
                 genre: str,
                 # ИСПРАВИТЬ: вы планируете передавать число года, записанное римскими цифрами, или может по китайскому календарю?) в фабрике и в примерах ниже вы создаёте экземпляр, передавая сюда int
                 year: str,
                 duration: int,
                 country: str,
                 # ИСПРАВИТЬ: полагаю, здесь должен быть кортеж/список Актёров — если только вы не составляете картотеку фильмов одного актёра...
                 actor: Actor,
                 # ИСПРАВИТЬ: снова несогласованность аннотированных и передаваемых типов — в статическом языке, типа С/С++/С#/Java/..., у вас только из-за этого уже был бы вагон исключений
                 reviews_from_users: int,
                 # ИСПРАВИТЬ: 'review' — это скорее 'обзор', чем 'оценка'; а с учётом того, что вы пишете об ожидании целого числа, кто-то может подумать что вы просите передать в этот параметр количество пользовательских обзоров/рецензий, а не оценку
                 reviews_from_critics: int,
                 # ИСПРАВИТЬ: полагаю, вы хотели 'slogan', а не 'title'
                 title: str
                 ):
        self.id = id_
        self.name = name
        # ИСПРАВИТЬ: нет никакого преимущества в том, чтобы хранить в атрибуте строку, вместо экземпляра перечислителя — строка вам понадобится только в __str__()
        self.genre = genre.name
        self.year = year
        self.duration = duration
        self.country = country
        # ИСПРАВИТЬ: чем хорош английский, в нём совершенно необязательны предлоги — уверен, что имена 'user_rate' и 'critic_rate' ничуть не хуже передают смысл содержимого атрибутов (множественное число также необязательно)
        self.reviews_from_users = reviews_from_users
        self.reviews_from_critics = reviews_from_critics
        self.title = title
        self.actor = actor

    def __str__(self):
        return (f'Фильм: {self.name}\n'
                f'\tID: {self.id}\n'
                # КОММЕНТАРИЙ: если бы в атрибуте self.genre у вас был экземпляр Genre, то здесь вам достаточно было бы обратится к его наименованию self.genre.name.title()
                f'\tЖанр: {self.genre}\n'
                f'\tГод: {self.year}\n'
                f'\tПродолжительность: {self.duration}\n'
                f'\tСтрана производства: {self.country}\n'
                f'\tАктёры: {self.actor}\n'
                f'\tОценка зрителей: {self.reviews_from_users}\n'
                f'\tОценка критиков: {self.reviews_from_critics}\n'
                f'\tСлоган: {self.title}')

    # УДАЛИТЬ: это свойство бесцельно дублирует существующее публичное поле
    @property
    def name_film(self):
        return self.name

    # УДАЛИТЬ: это свойство бесцельно дублирует существующее публичное поле
    @property
    def name_actor(self):
        return self.actor


class FilmCardFactory:
    """
    Создаёт и нумерует экземпляры FilmCard, используя объект класса.
    """
    id_ = 0
    dict_films = {}

    @classmethod
    def add_film(cls,
                 # ИСПРАВИТЬ: применить к параметрам и аннотациям релевантные комментарии к сигнатуре FilmCard.__init__()
                 name: str,
                 genre: Genre,
                 year: str,
                 duration: int,
                 country: str,
                 actor,
                 reviews_from_users: int,
                 reviews_from_critics: int,
                 title: str
                 ):
        """
        Добавляет информацию о фильме и присваивает индекс

        :param name: наименование фильма
        :param genre: жанр
        :param year: год выпуска
        :param duration: продолжительность
        :param country: страна
        :param actor: актер/актёры
        :param reviews_from_users: оценка зрителей
        :param reviews_from_critics: оценка критиков
        :param title: слоган
        """
        cls.id_ += 1
        if name in cls.dict_films.values():
            raise ValueError(f'Add another movie, this one already exists')
        else:
            cls.dict_films.update({cls.id_: name})
        return FilmCard(cls.id_,
                        name,
                        genre,
                        year,
                        duration,
                        country,
                        actor,
                        reviews_from_users,
                        reviews_from_critics,
                        title)


# УДАЛИТЬ: картотекой у вас получилась фабрика — а этот класс зачем тогда?
class CardIndex:
    """
    """
    # ИСПРАВИТЬ: конфликт имён со встроенной функцией list()
    list = []

    @classmethod
    # ИСПРАВИТЬ: не 'add_films', а 'add_film'
    def add_films(cls, film: FilmCard):
        """
        Создает общую картотеку фильмов

        :param: film: объект фильма
        """
        cls.list.append(film)
        return cls.list


# ИСПРАВИТЬ: класс здесь будет нужен, только если вы реализуете больше двух методов поиска по картотеке — в более простом случае, как здесь, вполне достаточно обычной функции
class FilmCardSearch:
    """
    """

    @staticmethod
    # ИСПРАВИТЬ: список чего? если фильмов, то films: list[FilmCard]
    # ИСПРАВИТЬ: с учётом того, что у вас есть отдельный класс Actor, вместо имени параметра actor лучше использовать actor_name
    def search(film: list, actor: str):
        """
        Осуществляет поиск фильмов, в которых снимался актер

        :param film: наименование фильма
        :param actor: имя актера
        """
        result = []
        # ИСПРАВИТЬ: этот цикл с первого раза читается, как перебор элементов (атрибутов?) одного фильма, что вводит в заблуждение
        for elem in film:
            # ИСПРАВИТЬ: когда вы писали этот цикл, вам должно было прийти в голову, что это неудобный способ проверять наличие актёра в фильме — и что раз уж в классе FilmCard есть свойство name_actor, то было бы неплохо его переписать так, чтобы оно возвращало список имён актёров, а не список объектов Actor, по которому вам сейчас приходится вручную итерироваться
            for i in elem.name_actor:
                # КОММЕНТАРИЙ: это условие с первого раза читается, как "если индекс равен актёру-строке", что бред
                # ИСПРАВИТЬ: никак в толк не возьму, почему даже несколько моих письменных комментариев на ту или иную тему не воспринимаются всерьёз — попробую выделить:
                #  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                #  !!! имена i, j, k использовать ТОЛЬКО для индексов !!!
                #  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                if i == actor:
                    result.append(elem.name_film)
        return f'Результат поиска: {result}'


# ИСПРАВИТЬ: экземпляры актёров не используются
actor1 = Actor('Джейк', 'Джейк Джилленхол').name
actor2 = Actor('Джейн', 'Эмми Россам').name

# УДАЛИТЬ: и зачем тогда экземпляр класса? в классе FilmCardFactory есть атрибуты класса и классовый метод — ничего, имеющего отношения к экземпляру там нет
film = FilmCardFactory()
film1 = film.add_film('Послезавтра',
                      # КОММЕНТАРИЙ: что такое 10? вот это и есть пример использования перечислителя как списка — избегайте такой практики
                      # ИСПРАВИТЬ: на Genre.FANTASY
                      Genre(10),
                      # КОММЕНТАРИЙ: нет уж, пишите тогда год римскими цифрами, раз ждёте здесь str )))
                      2004,
                      90,
                      'USA',
                      # КОММЕНТАРИЙ: вот как раз здесь должна была использоваться агрегация — когда один экземпляр пользовательского класса становится значением поля другого пользовательского класса — но вы сюда передаёте строки и весь смысл теряется
                      [actor1, actor2],
                      7.7,
                      6.4,
                      'Где будешь ты?')
print(film1)
print('___________________________________________________')

actor3 = Actor('Питер', 'Джейк Джилленхол').name
actor4 = Actor('Джесика', 'Дэвид Шайр').name

film2 = film.add_film('Зодиак',
                      Genre(3), 2007, 90, 'USA', [actor3, actor4], 6.5, 5.0, 'Есть много способов умереть от руки убийцы')
print(film2)
print('___________________________________________________')

actor5 = Actor('Эдвард Льюис', 'Ричард Гир').name
actor6 = Actor('Вивиан Уорд', 'Джулия Робертс').name

film3 = film.add_film('Красотка', Genre(1), 1990, 90, 'USA', [actor5, actor6], 8.5, 8.0, 'She walked off the street, into his life and stole his heart')
print(film3)
print('___________________________________________________')


# УДАЛИТЬ: аналогично FilmCardFactory — экземпляр не нужен
card = CardIndex()
card.add_films(film1)
card.add_films(film2)
card_film = card.add_films(film3)
print(FilmCardSearch.search(card_film, 'Джейк Джилленхол'))


# Фильм: Послезавтра
# 	ID: 1
# 	Жанр: Fantasy
# 	Год: 2004
# 	Продолжительность: 90
# 	Страна производства: USA
# 	Актеры: ['Джейк Джилленхол', 'Эмми Россам']
# 	Оценка зрителей: 7.7
# 	Оценка Критиков: 6.4
# 	Слоган: Где будешь ты?
# ___________________________________________________
# Фильм: Зодиак
# 	ID: 2
# 	Жанр: Drama
# 	Год: 2007
# 	Продолжительность: 90
# 	Страна производства: USA
# 	Актеры: ['Джейк Джилленхол', 'Дэвид Шайр']
# 	Оценка зрителей: 6.5
# 	Оценка Критиков: 5.0
# 	Слоган: Есть много способов умереть от руки убийцы
# ___________________________________________________
# Фильм: Красотка
# 	ID: 3
# 	Жанр: Romance
# 	Год: 1990
# 	Продолжительность: 90
# 	Страна производства: USA
# 	Актеры: ['Ричард Гир', 'Джулия Робертс']
# 	Оценка зрителей: 8.5
# 	Оценка Критиков: 8.0
# 	Слоган: She walked off the street, into his life and stole his heart
# ___________________________________________________
# Результат поиска: ['Послезавтра', 'Зодиак']


# КОММЕНТАРИЙ: видите ли, я трачу очень много времени на проверку заданий — а 90–95% этого времени уходит на собственно написание комментариев — если я вижу, что студент игнорирует мои комментарии, то я без радости, но с облегчением перестаю писать все эти многострочники и проверка работ данного студента с этого момента ограничивается выставлением баллов


# ИТОГ: сама фабрика реализована хорошо, но к объектной модели в целом вопросов довольно много, также не использована агрегация, проработайте приведённые комментарии — 6/10
