from random import choice


class Cards:
    """Случайный выбор игральной карты"""

    def __init__(self):
        # УДАЛИТЬ: этот атрибут не используется
        self.index = 0
        self._SUITS = ['черви', 'бубны', 'пики', 'крести']
        # ИСПРАВИТЬ: зря смешали в одном списке числа и строки — себе же усложнили дальнейшую потенциальную обработку этого списка — воспользуйтесь рекомендацией по номиналам из условия задачи
        self._RANKS = [*range(2, 11), 'J', 'Q', 'K', 'A']

    def __next__(self):
        suit = choice(self._SUITS)
        rank = choice(self._RANKS)
        # ИСПРАВИТЬ: напоминаю, что согласно условию задачи от вас требуется получить генератор — здесь генератора нет
        return f'({rank}, {suit})'

    def __iter__(self):
        # ИСПРАВИТЬ: вы получили бесконечный итератор, выдающий случайные карты, а не итератор колоды из 52 карт (см. тест ниже)
        return self


deck = Cards()
print(next(deck))

# КОММЕНТАРИЙ: при вычислении заголовка цикла от объекта deck вызывается метод __iter__(), который возвращает этот же самый объект — а от этого возвращённого объекта уже вызывается метод __next__(), возвращаемое значение которого записывается в переменную цикла card; поскольку нигде нет выброса исключения StopIteration, вся эта круговерть будет продолжаться и продолжаться
for card in deck:
    print(card, end=' ')


# СДЕЛАТЬ: вообще, здесь не требовалось писать класс — но раз уж взялись, то теперь переписывайте его так, чтобы это был корректный класс, с помощью которого можно управлять колодой, возвращать генератор и итерироваться по нему


# ДОБАВИТЬ: закомментированный вывод результатов нескольких запусков скрипта с различными входными данными (при наличии)
# tests:


# ИТОГ: доработать — 1/5
