# ИСПРАВИТЬ: имена; разве функция log_errors сохраняет только вызовы, завершившиеся ошибками? почему func_new, какую новую (и относительно чего новую) функцию должен принять этот параметр?
# ДОБАВИТЬ: аннотации типов параметров и возвращаемого значения
from datetime import datetime
from typing import Callable, Any

def log_file(function) -> Callable:
    # ИСПРАВИТЬ: документация функции/метода начинается с глагола и в одно предложение отвечает на вопрос "что делает функция/метод?"
    """Логирует вызов функции в файл-журнал"""

    # ИСПРАВИТЬ: а почему только два параметра? довольно странное решение — предназначить этот декоратор только для тех функций, которые принимают ровно два аргумента
    def wrapper(*args, **kwargs) -> Any:
        result = function(*args, **kwargs)
        # ИСПРАВИТЬ: снова "ошибки" вылезли откуда-то, теперь в имени файла
        file_name = 'log.txt'
        # ИСПРАВИТЬ: параметр mode является позиционно-ключевым и расположен на втором месте, так что ключ указывать не требуется; а вот кодировку вы зря не прописываете — так, например, ваш файл был создан в кодировке windows-1251, которая судя по всему является вашей системной кодировкой, но utf-8 предпочтительнее, потому как читается большим количеством приложений в разных операционных системах
        now = datetime.now()
        with open(file_name, 'a', encoding='utf-8') as fp:
        # ИСПРАВИТЬ: ваш файл и так содержит слово function в названии — зачем к каждому вызову дописывать слово "Функция"? перевод байт — так и получаются лог-файлы весом в гигабайты; возьмите аргументы в скобки — это ничуть не хуже покажет понимающему человеку, что перед ним вызов функции, а не понимающему ваша подпись тоже не так чтоб особенно поможет
            fp.write(f'{now} {function.__name__} \nArgs:{args} \nKwargs: {kwargs}\n')
        # ДОБАВИТЬ: файлы журналов и логов практически всегда используют отметки времени — неплохо было бы вам тоже добавить


        # ДОБАВИТЬ: все файлопотоки должны быть закрыты сразу по окончании работы с файлом! либо вручную с помощью метода close(), либо автоматически при использовании менеджера контекста with...as... — второй вариант предпочтительнее
        return result
    return wrapper


@log_file
def checkhand(a: int, b: int, c: int = 0) -> int:
    return a - b + c


print(checkhand(10, 0))
print(checkhand(a=99, b=2, c=45))

@log_file
def add_str(a: str, b: str) -> str:
    return a + ' ' + b

print(add_str(a='Hello', b='world'))


# ДОБАВИТЬ: закомментированный вывод результатов нескольких запусков скрипта с различными входными данными (при наличии)
# tests:
# 10
# 142
# Hello world

# ИТОГ: обратить внимание на работу с файлами — 2/5
