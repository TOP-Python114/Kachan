# ИСПРАВИТЬ: имена; разве функция log_errors сохраняет только вызовы, завершившиеся ошибками? почему func_new, какую новую (и относительно чего новую) функцию должен принять этот параметр?
# ДОБАВИТЬ: аннотации типов параметров и возвращаемого значения
def log_errors(func_new):
    # ИСПРАВИТЬ: документация функции/метода начинается с глагола и в одно предложение отвечает на вопрос "что делает функция/метод?"
    """Декоратор, который который логирует вызов функции в файл-журнал, используя атрибуты объекта функции __name__ и аргументы, переданные функции"""

    # ИСПРАВИТЬ: а почему только два параметра? довольно странное решение — предназначить этот декоратор только для тех функций, которые принимают ровно два аргумента
    def wrapper(a, b):
        result = func_new(a, b)
        # ИСПРАВИТЬ: снова "ошибки" вылезли откуда-то, теперь в имени файла
        file_name = 'function_errors.log'
        # ИСПРАВИТЬ: параметр mode является позиционно-ключевым и расположен на втором месте, так что ключ указывать не требуется; а вот кодировку вы зря не прописываете — так, например, ваш файл был создан в кодировке windows-1251, которая судя по всему является вашей системной кодировкой, но utf-8 предпочтительнее, потому как читается большим количеством приложений в разных операционных системах
        file = open(file_name, mode='a')
        # ИСПРАВИТЬ: ваш файл и так содержит слово function в названии — зачем к каждому вызову дописывать слово "Функция"? перевод байт — так и получаются лог-файлы весом в гигабайты; возьмите аргументы в скобки — это ничуть не хуже покажет понимающему человеку, что перед ним вызов функции, а не понимающему ваша подпись тоже не так чтоб особенно поможет
        file.write(f'Функция: {func_new.__name__} \n {a} \n {b} \n')
        # ДОБАВИТЬ: файлы журналов и логов практически всегда используют отметки времени — неплохо было бы вам тоже добавить

        # ДОБАВИТЬ: все файлопотоки должны быть закрыты сразу по окончании работы с файлом! либо вручную с помощью метода close(), либо автоматически при использовании менеджера контекста with...as... — второй вариант предпочтительнее
        return result
    return wrapper


@log_errors
def checkhand(a, b):
    return a - b


print(checkhand(10, 0))


# ДОБАВИТЬ: закомментированный вывод результатов нескольких запусков скрипта с различными входными данными (при наличии)
# tests:


# ИТОГ: обратить внимание на работу с файлами — 2/5
