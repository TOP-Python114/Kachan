#В нейросетевых вычислениях широко испольузются перестановки некоторого множества элементов.
#Перестановки — это комбинации из n различных элементов, отличающиеся позициями элементов. Количество перестановок P = n!
#для 2 элементов a, b:
#ab ba
#для 3 элементов a, b, c:
#abc bca cab acb cba bac
#Напишите функцию-генератор, принимающую на вход множество set, и возвращающую в строковом виде перестановки для элементов этого множества.

from itertools import permutations
from typing import Generator
# ИСПРАВИТЬ: имена всех переменных должны насколько возможно точно отражать ожидаемое содержимое — по смыслу; имя displace_str никак не говорит нам о том, что эта функция должна вернуть перестановки, имя array вообще является именем типа из стандартной библиотеки и никак не отражает, какой именно объект функция ожидает получить на вход
# ДОБАВИТЬ: аннотации типов параметров и возвращаемого значения


def rearrange_strings(text: {str}) -> Generator:
    # ИСПРАВИТЬ: документация функции/метода начинается с глагола и в одно предложение отвечает на вопрос "что делает функция/метод?"
    """
    Возвращает в строковом виде перестановки
    Пример:
    для 3 элементов: a, b, c:
    abc bca cab acb cba bac
    :param text: множество set
    """
    #text_add = []
    #i = 0
    #j = 0
    text = list(text)

    if not text:
        # Возвращает генератор при отсутствии первоначальных данных в виде множества элементов
        # КОММЕНТАРИЙ: это может быть вполне неплохим решением, но такое поведение должно быть задокументировано — отдельным предложением
        yield text
    else:
        # ИСПРАВИТЬ: для индексов мы традиционно используем имена i, j, k
        for i in range(len(text)):
            text_add = text[:i] + text[i + 1:]
            # ИСПРАВИТЬ: имя — разве итерируемые элементы функции-генератора представляют из себя счётчики?
            for j in rearrange_strings(text_add):
                yield text[i:i+1] + j

for elem in rearrange_strings({'a', 'b', 'c'}):
    # ИСПРАВИТЬ: второй join() лишний — посмотрите внимательно какие объекты у вас записываются в elem, и что вы с ними делаете
    print(''.join(elem))


# КОММЕНТАРИЙ: проводите больше тестов, используйте разные входные данные, проверяйте себя
own = {''.join(perm) for perm in rearrange_strings({'а', 'и', 'о', 'у', 'э'})}
ref = {''.join(perm) for perm in permutations({'а', 'и', 'о', 'у', 'э'})}
print(f'\n{own == ref = }')
string = {''.join(perm) for perm in rearrange_strings({'а1', 'и7', 'o1', 'j1254'})}
for el in string:
    print(el)

print(rearrange_strings({}))

# ДОБАВИТЬ: закомментированный вывод результатов нескольких запусков скрипта с различными входными данными (при наличии)
# tests:
# bca
# bac
# cba
# cab
# abc
# acb
#
# own == ref = True
# j1254o1и7а1
# o1и7j1254а1
# а1и7o1j1254
# j1254а1и7o1
# и7а1o1j1254
# j1254а1o1и7
# и7o1j1254а1
# и7j1254o1а1
# а1j1254o1и7
# а1o1j1254и7
# o1j1254а1и7
# j1254и7o1а1
# o1а1и7j1254
# o1и7а1j1254
# j1254o1а1и7
# и7j1254а1o1
# o1а1j1254и7
# а1и7j1254o1
# j1254и7а1o1
# а1j1254и7o1
# и7а1j1254o1
# o1j1254и7а1
# и7o1а1j1254
# а1o1и7j1254


# ИТОГ: критичных ошибок нет, но есть много аспектов, на которые необходимо обратить внимание — 4/6
