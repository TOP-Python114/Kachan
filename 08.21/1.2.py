

from itertools import permutations


# ИСПРАВИТЬ: имена всех переменных должны насколько возможно точно отражать ожидаемое содержимое — по смыслу; имя displace_str никак не говорит нам о том, что эта функция должна вернуть перестановки, имя array вообще является именем типа из стандартной библиотеки и никак не отражает, какой именно объект функция ожидает получить на вход
# ДОБАВИТЬ: аннотации типов параметров и возвращаемого значения
def displace_str(array):
    # ИСПРАВИТЬ: документация функции/метода начинается с глагола и в одно предложение отвечает на вопрос "что делает функция/метод?"
    """Функция-генератор, принимающая на вход множество set, и возвращающую в строковом виде перестановки для элементов этого множества"""
    # array_new = []
    # counter_1 = 0
    # counter_2 = 0
    array = list(array)
    if not array:
        # КОММЕНТАРИЙ: это может быть вполне неплохим решением, но такое поведение должно быть задокументировано — отдельным предложением
        yield array
    else:
        # ИСПРАВИТЬ: для индексов мы традиционно используем имена i, j, k
        for counter_1 in range(len(array)):
            array_new = array[:counter_1] + array[counter_1+1:]
            # ИСПРАВИТЬ: имя — разве итерируемые элементы функции-генератора представляют из себя счётчики?
            for counter_2 in displace_str(array_new):
                yield array[counter_1:counter_1+1] + counter_2


for elem in displace_str({'a', 'b', 'c'}):
    # ИСПРАВИТЬ: второй join() лишний — посмотрите внимательно какие объекты у вас записываются в elem, и что вы с ними делаете
    print(''.join(''.join(elem)))

# КОММЕНТАРИЙ: проводите больше тестов, используйте разные входные данные, проверяйте себя
own = {''.join(perm) for perm in displace_str({'а', 'и', 'о', 'у', 'э'})}
ref = {''.join(perm) for perm in permutations({'а', 'и', 'о', 'у', 'э'})}
print(f'\n{own == ref = }')


# ДОБАВИТЬ: закомментированный вывод результатов нескольких запусков скрипта с различными входными данными (при наличии)
# tests:


# ИТОГ: критичных ошибок нет, но есть много аспектов, на которые необходимо обратить внимание — 4/6
